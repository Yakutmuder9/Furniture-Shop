{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nexports.unstable_createStyleFunctionSx = unstable_createStyleFunctionSx;\n\nvar _merge = _interopRequireDefault(require(\"../merge\"));\n\nvar _getThemeValue = require(\"../getThemeValue\");\n\nvar _breakpoints = require(\"../breakpoints\");\n\nfunction objectsHaveSameKeys() {\n  for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {\n    objects[_key] = arguments[_key];\n  }\n\n  const allKeys = objects.reduce((keys, object) => keys.concat(Object.keys(object)), []);\n  const union = new Set(allKeys);\n  return objects.every(object => union.size === Object.keys(object).length);\n}\n\nfunction callIfFn(maybeFn, arg) {\n  return typeof maybeFn === 'function' ? maybeFn(arg) : maybeFn;\n} // eslint-disable-next-line @typescript-eslint/naming-convention\n\n\nfunction unstable_createStyleFunctionSx() {\n  let styleFunctionMapping = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _getThemeValue.styleFunctionMapping;\n  const propToStyleFunction = Object.keys(styleFunctionMapping).reduce((acc, styleFnName) => {\n    styleFunctionMapping[styleFnName].filterProps.forEach(propName => {\n      acc[propName] = styleFunctionMapping[styleFnName];\n    });\n    return acc;\n  }, {});\n\n  function getThemeValue(prop, value, theme) {\n    const inputProps = {\n      [prop]: value,\n      theme\n    };\n    const styleFunction = propToStyleFunction[prop];\n    return styleFunction ? styleFunction(inputProps) : {\n      [prop]: value\n    };\n  }\n\n  function styleFunctionSx(props) {\n    const {\n      sx,\n      theme = {}\n    } = props || {};\n\n    if (!sx) {\n      return null; // Emotion & styled-components will neglect null\n    }\n    /*\n     * Receive `sxInput` as object or callback\n     * and then recursively check keys & values to create media query object styles.\n     * (the result will be used in `styled`)\n     */\n\n\n    function traverse(sxInput) {\n      let sxObject = sxInput;\n\n      if (typeof sxInput === 'function') {\n        sxObject = sxInput(theme);\n      } else if (typeof sxInput !== 'object') {\n        // value\n        return sxInput;\n      }\n\n      if (!sxObject) {\n        return null;\n      }\n\n      const emptyBreakpoints = (0, _breakpoints.createEmptyBreakpointObject)(theme.breakpoints);\n      const breakpointsKeys = Object.keys(emptyBreakpoints);\n      let css = emptyBreakpoints;\n      Object.keys(sxObject).forEach(styleKey => {\n        const value = callIfFn(sxObject[styleKey], theme);\n\n        if (value !== null && value !== undefined) {\n          if (typeof value === 'object') {\n            if (propToStyleFunction[styleKey]) {\n              css = (0, _merge.default)(css, getThemeValue(styleKey, value, theme));\n            } else {\n              const breakpointsValues = (0, _breakpoints.handleBreakpoints)({\n                theme\n              }, value, x => ({\n                [styleKey]: x\n              }));\n\n              if (objectsHaveSameKeys(breakpointsValues, value)) {\n                css[styleKey] = styleFunctionSx({\n                  sx: value,\n                  theme\n                });\n              } else {\n                css = (0, _merge.default)(css, breakpointsValues);\n              }\n            }\n          } else {\n            css = (0, _merge.default)(css, getThemeValue(styleKey, value, theme));\n          }\n        }\n      });\n      return (0, _breakpoints.removeUnusedBreakpoints)(breakpointsKeys, css);\n    }\n\n    return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);\n  }\n\n  return styleFunctionSx;\n}\n\nconst styleFunctionSx = unstable_createStyleFunctionSx();\nstyleFunctionSx.filterProps = ['sx'];\nvar _default = styleFunctionSx;\nexports.default = _default;","map":{"version":3,"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","default","unstable_createStyleFunctionSx","_merge","_getThemeValue","_breakpoints","objectsHaveSameKeys","objects","allKeys","reduce","keys","object","concat","union","Set","every","size","length","callIfFn","maybeFn","arg","styleFunctionMapping","propToStyleFunction","acc","styleFnName","filterProps","forEach","propName","getThemeValue","prop","theme","inputProps","styleFunction","styleFunctionSx","props","sx","traverse","sxInput","sxObject","emptyBreakpoints","createEmptyBreakpointObject","breakpoints","breakpointsKeys","css","styleKey","undefined","breakpointsValues","handleBreakpoints","x","removeUnusedBreakpoints","Array","isArray","map","_default"],"sources":["C:/Users/yakut/Desktop/Portfolio/FurnitureShop/client/node_modules/@mui/system/styleFunctionSx/styleFunctionSx.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nexports.unstable_createStyleFunctionSx = unstable_createStyleFunctionSx;\n\nvar _merge = _interopRequireDefault(require(\"../merge\"));\n\nvar _getThemeValue = require(\"../getThemeValue\");\n\nvar _breakpoints = require(\"../breakpoints\");\n\nfunction objectsHaveSameKeys(...objects) {\n  const allKeys = objects.reduce((keys, object) => keys.concat(Object.keys(object)), []);\n  const union = new Set(allKeys);\n  return objects.every(object => union.size === Object.keys(object).length);\n}\n\nfunction callIfFn(maybeFn, arg) {\n  return typeof maybeFn === 'function' ? maybeFn(arg) : maybeFn;\n} // eslint-disable-next-line @typescript-eslint/naming-convention\n\n\nfunction unstable_createStyleFunctionSx(styleFunctionMapping = _getThemeValue.styleFunctionMapping) {\n  const propToStyleFunction = Object.keys(styleFunctionMapping).reduce((acc, styleFnName) => {\n    styleFunctionMapping[styleFnName].filterProps.forEach(propName => {\n      acc[propName] = styleFunctionMapping[styleFnName];\n    });\n    return acc;\n  }, {});\n\n  function getThemeValue(prop, value, theme) {\n    const inputProps = {\n      [prop]: value,\n      theme\n    };\n    const styleFunction = propToStyleFunction[prop];\n    return styleFunction ? styleFunction(inputProps) : {\n      [prop]: value\n    };\n  }\n\n  function styleFunctionSx(props) {\n    const {\n      sx,\n      theme = {}\n    } = props || {};\n\n    if (!sx) {\n      return null; // Emotion & styled-components will neglect null\n    }\n    /*\n     * Receive `sxInput` as object or callback\n     * and then recursively check keys & values to create media query object styles.\n     * (the result will be used in `styled`)\n     */\n\n\n    function traverse(sxInput) {\n      let sxObject = sxInput;\n\n      if (typeof sxInput === 'function') {\n        sxObject = sxInput(theme);\n      } else if (typeof sxInput !== 'object') {\n        // value\n        return sxInput;\n      }\n\n      if (!sxObject) {\n        return null;\n      }\n\n      const emptyBreakpoints = (0, _breakpoints.createEmptyBreakpointObject)(theme.breakpoints);\n      const breakpointsKeys = Object.keys(emptyBreakpoints);\n      let css = emptyBreakpoints;\n      Object.keys(sxObject).forEach(styleKey => {\n        const value = callIfFn(sxObject[styleKey], theme);\n\n        if (value !== null && value !== undefined) {\n          if (typeof value === 'object') {\n            if (propToStyleFunction[styleKey]) {\n              css = (0, _merge.default)(css, getThemeValue(styleKey, value, theme));\n            } else {\n              const breakpointsValues = (0, _breakpoints.handleBreakpoints)({\n                theme\n              }, value, x => ({\n                [styleKey]: x\n              }));\n\n              if (objectsHaveSameKeys(breakpointsValues, value)) {\n                css[styleKey] = styleFunctionSx({\n                  sx: value,\n                  theme\n                });\n              } else {\n                css = (0, _merge.default)(css, breakpointsValues);\n              }\n            }\n          } else {\n            css = (0, _merge.default)(css, getThemeValue(styleKey, value, theme));\n          }\n        }\n      });\n      return (0, _breakpoints.removeUnusedBreakpoints)(breakpointsKeys, css);\n    }\n\n    return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);\n  }\n\n  return styleFunctionSx;\n}\n\nconst styleFunctionSx = unstable_createStyleFunctionSx();\nstyleFunctionSx.filterProps = ['sx'];\nvar _default = styleFunctionSx;\nexports.default = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}